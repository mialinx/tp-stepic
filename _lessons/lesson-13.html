---
num: 13
title: Отображение данных
description: "Отображение страницы объекта. 404-страницы. Отображение связанных сущностей. Отображение списка объектов. Постраничное отображение. Progressive loading."
---

<section class="slide shout">
    <div>
        <h2>Типичные сценарии web-приложений</h2>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Типичные сценарии</h2>
        <ul>
            <li>Отображение объекта</li>
            <li>Отображение списка объектов</li>
            <li>Обработка форм и изменение объектов</li>
            <li>Авторизация и сессии пользователей</li>
            <li>Запуск фоновых процессов</li>
            <li>Интеграция с внешними системами</li>
        </ul>
    </div>
</section>

<section class="slide shout">
    <div>
        <h2>Отображение объекта</h2>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Маршрут в urls.py</h2>
        <script type="snippet" lang="python">
            # blog/urls.py
            urlpatterns = [
                url(r'^post/(?P<slug>\w+)/$', post_details, 
                    name='post-details'),        
                url(r'^tag/(?P<slug>\w+)/$', tag_details, 
                    name='tag-details'),        
            ]
        </script>
        <p>
            Часто на объекты ссылаются не по <b>id</b>, а по <b>slug</b>.
            Это позволяет строить более запоминающиеся для человека URL.
        </p>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Базовый view</h2>
        <script type="snippet" lang="python">
            from django.http import Http404
            from django.shortcuts import render

            def post_details(request, slug):
                try:
                    post = Post.objects.get(slug=slug)
                except Post.DoesNotExist:
                    raise Http404
                return render(request, 'blog/post_details.html', {
                    'post':     post,
                })
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Использование shortcut'ов</h2>
        <script type="snippet" lang="python">
            from django.shortcuts import render, get_object_or_404
            from django.views.decorators.http import require_GET

            @require_GET
            def post_details(request, slug):
                post = get_object_or_404(Post, slug=slug)
                return render(request, 'blog/post_details.html', {
                    'post':     post,
                })
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Связанные сущности</h2>
        <script type="snippet" lang="python">
            def post_details(request, slug):
                post = get_object_or_404(Post, slug=slug)
                try:
                    vote = post.votes.filter(user=request.user)[0]
                except Vote.DoesNotExist:
                    vote = None
                return render(request, 'blog/post_details.html', {
                    'post':     post,
                    'category': post.category,
                    'tags':     post.tags.all()[:],
                    'vote':     vote,
                })
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Связанные сущности</h2>
        <script type="snippet" lang="django"> {% raw %}
            <h1>{{ post.category.title }} - {{ post.title }}</h1>
            {% for tag in post.tags.all %}
                <a href="{{ tag.get_url }}">{{ tag }}</a>
            {% endfor %}
        {% endraw %} </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Методы в моделях</h2>
        <script type="snippet" lang="python">
            from django.core.urlresolvers import reverse

            class Tag(models.Model):
                slug  = models.SlugField(unique=True)
                title = models.CharField(max_length=64)

                def get_url(self):
                    return reverse('blog:tag-details', 
                        kwargs={'slug': self.slug})

                def __unicode__(self):
                    return self.title
        </script>
    </div>
</section>

<section class="slide shout">
    <div>
        <h2>Отображение списка объектов</h2>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Постраничное отображение</h2>
        <script type="snippet" lang="python">
            from django.core.paginator import Paginator
            def post_list_all(request):
                posts = Post.objects.filter(is_published=True)
                limit = request.GET.get('limit', 10)
                page = request.GET.get('page', 1)
                paginator = Paginator(posts, limit)
                paginator.baseurl = '/blog/all_posts/?page='
                page = paginator.page(page)  # Page
                return render(request, 'blog/post_by_tag.html', {
                    'posts':  page.object_list,
                    'paginator': paginator, 'page': page,
                })
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Шаблон paginator</h2>
        <script type="snippet" lang="django"> {% raw %}
            <nav><ul class="pagination">
            {% for p in paginator.page_range %}
              {% if p.number == page.number %}
              <li class="active">
              {% else %}
              <li>
              {% endif %}
                <a href="{{ paginator.baseurl }}{{ p.number }}">
                {{ p.number }}</a>
              </li>
            {% endfor %}
            </ul></nav>
        {% endraw %} </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>django.core.paginator.Paginator</h2>
        <h3>Свойства</h3>
        <ul>
            <li><code>count</code> - полное число объектов</li>
            <li><code>num_pages</code> - полное число страниц</li>
            <li><code>page_range</code> - список страниц, например <code>[1, 2, 3, 4]</code></li>
        </ul>
        <h3>Методы</h3>
        <ul>
            <li><code>page(n)</code> - получить n-тый объект <code>Page</code></li>
        </ul>
    </div>
</section>

<section class="slide">
    <div>
        <h2>django.core.paginator.Page</h2>
        <h3>Свойства</h3>
        <ul>
            <li><code>object_list</code> - список объектов на странице</li>
            <li><code>number</code> - порядковый номер страницы</li>
        </ul>
        <h3>Методы</h3>
        <ul>
            <li><code>has_next()</code>/<code>has_previous()</code> - наличие соседней страницы</li>
            <li><code>next_page_number()</code>/<code>previous_page_number()</code></li>
            <li><code>start_index()</code>/<code>end_index()</code> - номера первого и последнего объектов на странице</li>
        </ul>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Best practices</h2>
        <ul>
            <li>Проверять валидность параметров <code>page</code> и <code>limit</code></li>
            <li>Отображать 404 ошибку при некорректных параметрах</li>
            <li>Ограничивать максимальное значение <code>limit</code> &lt;= 1000</li>
            <li>Обрабатывать &laquo;пустую&raquo; последнюю страницу</li>
        </ul>
    </div>
</section>

<section class="slide">
    <div>
        <script type="snippet" lang="python">
            def paginate(request, qs):
                try:
                    limit = int(request.GET.get('limit', 10))
                except ValueError:
                    limit = 10
                if limit > 100:
                    limit = 10
                try:
                    page = int(request.GET.get('page', 1))
                except ValueError:
                    raise Http404
                paginator = Paginator(qs, limit)
                try:
                    page = paginator.page(page)
                except EmptyPage:
                    page = paginator.page(paginator.num_pages)
                return page
        </script>
    </div>
</section>

<section class="slide shout">
    <div>
        <h2>Progressive loading</h2>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Progressive loading</h2>
        <p><b>Постраничная загрузка</b> хорошо работает в тех случаях, когда легко определить число объектов, подходящих
            под поисковый запрос. Другими словами - когда можно составить эффективный SQL запрос.</p>
        <p>Иногда это сделать сложно, например: &laquo;отображать все посты в порядке добавления, но не больше одного поста из одной категории подряд&raquo;.</p>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Свой ModelManager</h2>
        <p style="font-size: 85%">
            <script type="snippet" lang="python">
                class PostManager(models.Manager):
                    def main(self, since, limit=10):
                        qs = self.order_by('-id')
                        res = []
                        if since is not None:
                            qs = qs.filter('id__lt'=since)
                        for p in qs[:1000]:
                            if len(res):
                                res.append(p)        
                            elif res[-1].category != p.category:
                                res.append(p)
                            if len(res) >= limit:
                                break
                        return res
            </script>
        </p>
    </div>
</section>

<section class="slide">
    <div>
        <h2>view и шаблон</h2>
        <script type="snippet" lang="python">
            def post_list_main(request):
                since = request.GET.get('since')
                posts = Post.objects.main(since)
                return render(request, 'blog/post_main.html', {
                    'posts': posts,
                    'since': posts[-1].id,
                })
        </script>
        <script type="snippet" lang="python"> {% raw %}
            <a href="/blog/main/?since={{ since }}">Далее</a>
        {% endraw %} </script>
    </div>
</section>
