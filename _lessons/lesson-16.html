---
num: 16
title: Технология AJAX
description: "AJAX на стороне клиента. AJAX запросы с использованием jQuery. Передача HTML и JSON в AJAX запросах. Особенности контроллеров для AJAX. Cross Origin Resource Sharing."
---

<section class="slide shout">
    <div>
        <h2>AJAX</h2>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Asynchronous JavaScript And XML</h2>
        <p><b>AJAX</b> - технология загрузки данных / отправки форм без обновления WEB страницы.</p>
        <p>
            XML - совершенно не обязателен, возможны отправка и прием данных любого типа.
            Чаще всего вместо XML используется HTML либо JSON для загрузки сырых данных.
        </p>
    </div>
</section>

<section class="slide">
    <div>
        <h2>AJAX на стороне клиента</h2>
        <script type="snippet" lang="javascript">
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/xhr/test.html', true);
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        alert(xhr.responseText);
                    }
                }
            };
            xhr.send("a=5&b=4");
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>AJAX при помощи jQuery</h2>
        <script type="snippet" lang="javascript">
            $.ajax({
                url:  '/blog/comments/add/', 
                type: 'POST',
                data: { post_id: 12, text: 'Занятная идея!' },
            }).success(function(data) {
                if (data.status == 'ok') {
                    console.log(data.comment_id);
                }
            }).error(function() {
                console.log('http error')
            });
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Особенности и ограничения AJAX</h2>
        <ul>
            <li><b>Same Origin Policy</b> - AJAX запросы можно отправлять только на свой домен. В современных браузерах есть CORS.</li>
            <li>Т.к. данные передаются явно в метод <code>send</code>, то <b>нельзя загружать файлы</b>. В HTML5 есть FormData.</li>
            <li>AJAX на стороне сервера не отличим от обычного запроса. jQuery добавляет заголовок <code>X-Requested-With: XMLHttpRequest</code></li>
            <li>Результаты запроса передаются в JavaScript функцию поэтому стандартные методы обработки ошибок - не работают.</li>
        </ul>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Загрузка HTML данных</h2>
        <script type="snippet" lang="python">
            def comments_list(request):
                post_id = request.GET.get('post_id')
                post = get_object_or_404(Post, post_id)
                comments = paginate(request, post.comments)
                return render(request, 'blog/comments.html', {
                    'comments': comments
                })
        </script>
        <p>В <code>blog/comments.html</code> отображается только HTML код комментариев, без окружающей страницы.</p>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Обмен данными в JSON</h2>
        <script type="snippet" lang="javascript">
            {
                "status": "ok",
                "comment_id": 123
            }
        </script>
        <script type="snippet" lang="javascript">
            {
                "status": "error",
                "code":   "no_auth",
                "message":"вы не авторизованы"
            }
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>HttpResponseAjax</h2>
        <script type="snippet" lang="python">
            import json

            class HttpResponseAjax(HttpResponse):
                def __init__(self, status='ok', **kwargs):
                    kwargs['status'] = status
                    super(HttpResponseAjax, self).__init__(
                        content = json.dumps(kwargs),
                        content_type = 'application/json',
                    )
            class HttpResponseAjaxError(HttpResponseAjax):
                def __init__(self, code, message):
                    super(HttpResponseAjaxError, self).__init__(
                        status = 'error', code = code, message = message
                    )
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Использование HttpResponseAjax</h2>
        <script type="snippet" lang="python">
            @login_required_ajax
            def comment_add(request):
                form = AddCommentForm(request.POST)
                if form.is_valid():
                    comment = form.save()
                    return HttpResponseAjax(comment_id=comment.id)
                else:
                    return HttpResponseAjaxError(
                        code = "bad_params",
                        message = form.errors.as_text(), 
                    )
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Проверка авторизации в AJAX</h2>
        <script type="snippet" lang="python">
            def login_required_ajax(view):
                def view2(request, *args, **kwargs):
                    if request.user.is_authenticated():
                        return view(request, *args, **kwargs)
                    elif request.is_ajax():
                        return HttpResponseAjaxError(
                            code = "no_auth",
                            message = u'Требуется авторизация',
                        )
                    else:
                        redirect('/login/?continue=' + request.get_full_path())
                return view2
        </script> 
    </div>
</section>

<section class="slide shout">
    <div>
        <h2>CORS</h2>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Cross Origin Resource Sharing</h2>
        <p>Браузер выполняет AJAX запросы даже к чужому домену, но в этом случае не вызывает функцию-callback в JavaScript, т.е. 
            не дает использовать данные, загруженные с чужого домена.</p>
        <p><b>CORS</b> позволяет серверу явно разрешить использование данных при кросс-доменных запросах.</p>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Cross Origin Resource Sharing</h2>
        <img src="{{ site.pictures_url }}/lesson-16/cors.png" class="center">
    </div>
</section>

<section class="slide">
    <div>
        <h2>Заголовки CORS</h2>
        <ul>
            <li><code>Origin</code> - указывает URL запрашивающего приложения</li>
            <li><code>Access-Control-Allow-Origin: origin</code> - разрешает использовать данные в кросс-доменном запросе. 
                <code>origin</code> должен либо совпадать с загловком <code>Origin</code> в запросе, либо <code>*</code>.</li>
            <li><code>Access-Control-Allow-Credentials</code> - позволяет использовать данные, если были переданы cookies.</li>
        </ul>
    </div>
</section>

<section class="slide">
    <div>
        <h2>Использование CORS</h2>
        <p>
            Не следует разрешать CORS для всех запросов (<code>*</code>).<br>
            Хорошей практикой является:
            <ul>
                <li>Проверка суффикса домена</li>
                <li>Проверка домена по списку доверенных</li>
            </ul>
        </p>
    </div>
</section>

<section class="slide">
    <div>
        <h2>CORS на клиенте</h2>
        <script type="snippet" lang="javascript">
            $.ajax({
                url:  'https://site.com/blog/comments/add/', 
                type: 'POST',
                data: { post_id: 12, text: 'Занятная идея!' },
                crossDomain: true,
                xhrFields: {
                    withCredentials: true
                }
            }).success(function(data) {
                // ...
            });
        </script>
    </div>
</section>

<section class="slide">
    <div>
        <h2>CORS на сервере</h2>
        <script type="snippet" lang="python">
            def allow_cors(view):
                def view2(request, *args, **kwargs):
                    response = view(request, *args, **kwargs)
                    origin = request.META.get('HTTP_ORIGIN')
                    if not origin:
                        return response
                    for domain in settings.CORS_WHITE_LIST:
                        if origin.endswith('.' + domain):
                            response['Access-Control-Allow-Origin'] = origin
                    return response
                return view2
        </script> 
    </div>
</section>
